{"version":3,"sources":["webpack:///./src/panels/lovelace/common/structs/struct.ts","webpack:///./src/panels/lovelace/common/structs/is-entity-id.ts","webpack:///./src/panels/lovelace/common/structs/is-icon.ts","webpack:///./node_modules/superstruct/lib/index.es.js","webpack:///./src/panels/lovelace/components/hui-yaml-editor.ts","webpack:///./src/panels/lovelace/hui-editor.ts"],"names":["struct","types","value","includes","icon","StructError","TypeError","attrs","type","path","length","join","JSON","stringify","super","format","data","reason","errors","this","push","Error","captureStackTrace","constructor","stack","toString","Object","prototype","kindOf","val","ctorName","Array","isArray","isBuffer","callee","err","message","indexOf","isArguments","Date","toDateString","getDate","setDate","isDate","stackTraceLimit","isError","RegExp","flags","ignoreCase","multiline","global","isRegexp","throw","return","next","isGeneratorObj","call","slice","toLowerCase","replace","name","IS_STRUCT","KIND","isStruct","resolveDefaults","defaults","_extends","assign","target","i","arguments","source","key","hasOwnProperty","Kind","validate","any","schema","defaults$$1","options","tuple","list","func","object","required","endsWith","union","split","intersection","scalar","optional","undefined","en","map","s","e","String","result","isValid","failure","array","element","error","ret","v","r","forEach","singleE","concat","obj","ks","properties","kind","valueKeys","keys","propertiesKeys","Set","fn","kinds","k","Math","max","t","Kinds","dict","values","resolved","e2","r2","enum","enums","function","instance","interface","lazy","literal","partial","dynamic","createSchema","Types","superstruct","config","Struct","assert","defineProperty","test","date","isNaN","HuiYamlEditor","HTMLElement","commands","save","cm","getWrapperElement","_value","attachShadow","mode","innerHTML","hass","_hass","setScrollBarDirection","codemirror","getValue","setValue","shadowRoot","querySelector","refresh","lineNumbers","tabSize","autofocus","viewportMargin","Infinity","extraKeys","Tab","gutters","on","_onChange","classList","toggle","lovelaceStruct","title","views","resources","customElements","define","lovelace","closeEditor","_saving","_changed","_closeEditor","localize","saved","_handleSave","_yamlChanged","yamlEditor","safeDump","clearHistory","_generation","changeGeneration","isClean","window","onbeforeunload","confirm","hasComments","safeLoad","alert","saveConfig"],"mappings":"oGAAA,kCAIO,MAAMA,EAAS,YAAY,CAChCC,MAAO,CACL,YCNG,SAAoBC,GACzB,MAAqB,iBAAVA,EACF,iCAEJA,EAAMC,SAAS,MACX,qDDEPC,KEPG,SAAgBF,GACrB,MAAqB,iBAAVA,EACF,4BAEJA,EAAMC,SAAS,MACX,+C,iCCLX,kCAMA,MAAME,UAAoBC,UACxB,cAAcC,GACZ,MAAM,KAAEC,EAAI,KAAEC,EAAI,MAAEP,GAAUK,EAE9B,oCAD8CC,MAASC,EAAKC,iBAAmBD,EAAKE,KAAK,SAAW,qBAAqBC,KAAKC,UAAUX,QAI1I,YAAYK,GAEVO,MADgBT,EAAYU,OAAOR,IAGnC,MAAM,KAAES,EAAI,KAAEP,EAAI,MAAEP,EAAK,OAAEe,EAAM,KAAET,EAAI,OAAEU,EAAS,IAAOX,EACzDY,KAAKH,KAAOA,EACZG,KAAKV,KAAOA,EACZU,KAAKjB,MAAQA,EACbiB,KAAKF,OAASA,EACdE,KAAKX,KAAOA,EACZW,KAAKD,OAASA,EAETA,EAAOR,QACVQ,EAAOE,KAAKD,MAGVE,MAAMC,kBACRD,MAAMC,kBAAkBH,KAAMA,KAAKI,aAEnCJ,KAAKK,OAAQ,IAAIH,OAAQG,OAK/B,IAAIC,EAAWC,OAAOC,UAAUF,SAE5BG,EAAS,SAAgBC,GAC3B,QAAY,IAARA,EAAgB,MAAO,YAC3B,GAAY,OAARA,EAAc,MAAO,OAEzB,IAAIrB,SAAcqB,EAClB,GAAa,YAATrB,EAAoB,MAAO,UAC/B,GAAa,WAATA,EAAmB,MAAO,SAC9B,GAAa,WAATA,EAAmB,MAAO,SAC9B,GAAa,WAATA,EAAmB,MAAO,SAC9B,GAAa,aAATA,EACF,MAoFwB,sBAAnBsB,EApFgBD,GAAO,oBAAsB,WAGpD,GAwDF,SAAiBA,GACf,OAAIE,MAAMC,QAAgBD,MAAMC,QAAQH,GACjCA,aAAeE,MA1DlBC,CAAQH,GAAM,MAAO,QACzB,GA2GF,SAAkBA,GAChB,GAAIA,EAAIN,aAAmD,mBAA7BM,EAAIN,YAAYU,SAC5C,OAAOJ,EAAIN,YAAYU,SAASJ,GAElC,OAAO,EA/GHI,CAASJ,GAAM,MAAO,SAC1B,GAwFF,SAAqBA,GACnB,IACE,GAA0B,iBAAfA,EAAInB,QAA6C,mBAAfmB,EAAIK,OAC/C,OAAO,EAET,MAAOC,GACP,IAAuC,IAAnCA,EAAIC,QAAQC,QAAQ,UACtB,OAAO,EAGX,OAAO,EAlGHC,CAAYT,GAAM,MAAO,YAC7B,GA8DF,SAAgBA,GACd,OAAIA,aAAeU,MACgB,mBAArBV,EAAIW,cACU,mBAAhBX,EAAIY,SACY,mBAAhBZ,EAAIa,QAlEZC,CAAOd,GAAM,MAAO,OACxB,GAyDF,SAAiBA,GACf,OAAOA,aAAeR,OAAiC,iBAAhBQ,EAAIO,SAAwBP,EAAIN,aAA0D,iBAApCM,EAAIN,YAAYqB,gBA1DzGC,CAAQhB,GAAM,MAAO,QACzB,GAmEF,SAAkBA,GAChB,OAAIA,aAAeiB,QACS,iBAAdjB,EAAIkB,OACa,kBAAnBlB,EAAImB,YACc,kBAAlBnB,EAAIoB,WACW,kBAAfpB,EAAIqB,OAxEZC,CAAStB,GAAM,MAAO,SAE1B,OAAQC,EAASD,IACf,IAAK,SAAU,MAAO,SACtB,IAAK,UAAW,MAAO,UAGvB,IAAK,UAAW,MAAO,UACvB,IAAK,UAAW,MAAO,UACvB,IAAK,MAAO,MAAO,MACnB,IAAK,MAAO,MAAO,MAGnB,IAAK,YAAa,MAAO,YACzB,IAAK,aAAc,MAAO,aAC1B,IAAK,oBAAqB,MAAO,oBAGjC,IAAK,aAAc,MAAO,aAC1B,IAAK,cAAe,MAAO,cAG3B,IAAK,aAAc,MAAO,aAC1B,IAAK,cAAe,MAAO,cAC3B,IAAK,eAAgB,MAAO,eAC5B,IAAK,eAAgB,MAAO,eAG9B,GAmDF,SAAwBA,GACtB,MAA4B,mBAAdA,EAAIuB,OACS,mBAAfvB,EAAIwB,QACS,mBAAbxB,EAAIyB,KAtDZC,CAAe1B,GACjB,MAAO,YAKT,OADArB,EAAOiB,EAAS+B,KAAK3B,IAEnB,IAAK,kBAAmB,MAAO,SAE/B,IAAK,wBAAyB,MAAO,cACrC,IAAK,wBAAyB,MAAO,cACrC,IAAK,2BAA4B,MAAO,iBACxC,IAAK,0BAA2B,MAAO,gBAIzC,OAAOrB,EAAKiD,MAAM,GAAI,GAAGC,cAAcC,QAAQ,MAAO,KAGxD,SAAS7B,EAASD,GAChB,OAAOA,EAAIN,YAAcM,EAAIN,YAAYqC,KAAO,KAoElD,MAAMC,EAAY,iBAQZC,EAAO,eASb,SAASC,EAAS7D,GAChB,SAAUA,IAASA,EAAM2D,IAW3B,SAASG,EAAgBC,EAAU/D,GACjC,MAA2B,mBAAb+D,EAA0BA,EAAS/D,GAAS+D,EAG5D,IAAIC,EAAWxC,OAAOyC,QAAU,SAAUC,GACxC,IAAK,IAAIC,EAAI,EAAGA,EAAIC,UAAU5D,OAAQ2D,IAAK,CACzC,IAAIE,EAASD,UAAUD,GAEvB,IAAK,IAAIG,KAAOD,EACV7C,OAAOC,UAAU8C,eAAejB,KAAKe,EAAQC,KAC/CJ,EAAOI,GAAOD,EAAOC,IAK3B,OAAOJ,GAST,MAAMM,EACJ,YAAYd,EAAMpD,EAAMmE,GACtBxD,KAAKyC,KAAOA,EACZzC,KAAKX,KAAOA,EACZW,KAAKwD,SAAWA,GAYpB,SAASC,EAAIC,EAAQC,EAAaC,GAChC,GAAIhB,EAASc,GACX,OAAOA,EAAOf,GAGhB,GAAIe,aAAkBH,EACpB,OAAOG,EAGT,OAAQjD,EAAOiD,IACb,IAAK,QAED,OAAOA,EAAOnE,OAAS,EAAIsE,EAAMH,EAAQC,EAAaC,GAAWE,EAAKJ,EAAQC,EAAaC,GAG/F,IAAK,WAED,OAAOG,EAAKL,EAAQC,EAAaC,GAGrC,IAAK,SAED,OAAOI,EAAON,EAAQC,EAAaC,GAGvC,IAAK,SACH,CACE,IACIvE,EADA4E,GAAW,EAQf,GALIP,EAAOQ,SAAS,OAClBD,GAAW,EACXP,EAASA,EAAOpB,MAAM,GAAI,IAGxBoB,EAAO1E,SAAS,KAAM,CAExBK,EAAO8E,EADST,EAAOU,MAAM,aACPT,EAAaC,QAC9B,GAAIF,EAAO1E,SAAS,KAAM,CAE/BK,EAAOgF,EADSX,EAAOU,MAAM,YACAT,EAAaC,QAE1CvE,EAAOiF,EAAOZ,EAAQC,EAAaC,GAOrC,OAJKK,IACH5E,EAAOkF,EAASlF,OAAMmF,EAAWZ,IAG5BvE,GAOX,MAAM,IAAIa,yBAAyBwD,KAmFvC,SAASe,EAAGf,EAAQC,EAAaC,GAC/B,GAAuB,UAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,MACMrE,EAAOqE,EAAOgB,IAAIC,IACtB,IACE,OAAOlF,KAAKC,UAAUiF,GACtB,MAAOC,GACP,OAAOC,OAAOF,MAEfnF,KAAK,OAMR,OAAO,IAAI+D,EAbE,OAaSlE,EAJL,CAACN,EAAQ8D,EAAgBc,KACjCD,EAAO1E,SAASD,GAAS,MAACyF,EAAWzF,GAAS,CAAC,CAAEc,KAAMd,EAAOO,KAAM,GAAIP,QAAOM,UA4B1F,SAAS0E,EAAKL,EAAQC,EAAaC,GACjC,GAAuB,aAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KA0CvC,OAAO,IAAIH,EAtCE,WACA,aACI,CAACxE,EAAQ8D,EAAgBc,GAAc9D,KACtD,MAAMiF,EAASpB,EAAO3E,EAAOc,GAC7B,IACIkF,EADAC,EAAU,CAAE1F,KAAM,GAAIQ,OAAQ,MAGlC,OAAQW,EAAOqE,IACb,IAAK,UAEDC,EAAUD,EACV,MAEJ,IAAK,SAEDC,GAAU,EACVC,EAAQlF,OAASgF,EACjB,MAEJ,IAAK,SAEDC,GAAU,EACVC,EAAUjC,EAAS,GAAIiC,EAASF,GAChC,MAEJ,QAKM,MAAM,IAAI5E,yBAAyB4E,KAK3C,OAAOC,EAAU,MAACP,EAAWzF,GAAS,CAACgE,EAAS,CAAE1D,KAlCvC,aAkC6CN,QAAOc,KAAMd,GAASiG,MAoLlF,SAASlB,EAAKJ,EAAQC,EAAaC,GACjC,GAAuB,UAAnBnD,EAAOiD,IAAyC,IAAlBA,EAAOnE,OAIrC,MAAM,IAAIW,yBAAyBwD,KAIvC,MAAMuB,EAAQX,EAAO,aAASE,EAAWZ,GACnCsB,EAAUzB,EAAIC,EAAO,QAAIc,EAAWZ,GAEpCvE,MAAW6F,EAAQ7F,QAiCzB,OAAO,IAAIkE,EAlCE,OAkCSlE,EAhCL,CAACN,EAAQ8D,EAAgBc,MACxC,MAAOwB,EAAOL,GAAUG,EAAMzB,SAASzE,GAEvC,GAAIoG,EAEF,OADAA,EAAM9F,KAAOA,EACN,CAAC8F,GAGVpG,EAAQ+F,EACR,MAAM/E,EAAS,GACTqF,EAAM,GAEZ,IAAK,IAAIlC,EAAI,EAAGA,EAAInE,EAAMQ,OAAQ2D,IAAK,CACrC,MAAMmC,EAAItG,EAAMmE,IACT0B,EAAGU,GAAKJ,EAAQ1B,SAAS6B,GAEhC,GAAIT,EAAJ,EACeA,EAAE7E,QAAU,CAAC6E,IACrBW,QAAQC,IACXA,EAAQlG,KAAO,CAAC4D,GAAGuC,OAAOD,EAAQlG,MAClCkG,EAAQ3F,KAAOd,EACfgB,EAAOE,KAAKuF,UAKhBJ,EAAIlC,GAAKoC,EAGX,OAAOvF,EAAOR,OAAS,CAACwD,EAAS,GAAIhD,EAAO,GAAI,CAAEA,YAAa,MAACyE,EAAWY,KAgC/E,SAASpB,EAAON,EAAQC,EAAaC,GACnC,GAAuB,WAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,MAAMgC,EAAMpB,EAAO,cAAUE,EAAWZ,GAClC+B,EAAK,GACLC,EAAa,GAEnB,IAAK,MAAMvC,KAAOK,EAAQ,CACxBiC,EAAG1F,KAAKoD,GACR,MACMwC,EAAOpC,EADHC,EAAOL,QACGmB,EAAWZ,GAC/BgC,EAAWvC,GAAOwC,EAGpB,MACMxG,MAAWsG,EAAGnG,UAkDpB,OAAO,IAAI+D,EAnDE,SAmDSlE,EAjDL,CAACN,EAAQ8D,EAAgBc,MACxC,MAAOwB,GAASO,EAAIlC,SAASzE,GAE7B,GAAIoG,EAEF,OADAA,EAAM9F,KAAOA,EACN,CAAC8F,GAGV,MAAMpF,EAAS,GACTqF,EAAM,GACNU,EAAYvF,OAAOwF,KAAKhH,GACxBiH,EAAiBzF,OAAOwF,KAAKH,GAmCnC,OAlCa,IAAIK,IAAIH,EAAUL,OAAOO,IAEjCT,QAAQlC,IACX,IAAIgC,EAAItG,EAAMsE,GACd,MAAMwC,EAAOD,EAAWvC,GAExB,QAAUmB,IAANa,EAAiB,CAEnBA,EAAIxC,EADMc,GAAeA,EAAYN,GACdtE,GAGzB,IAAK8G,EAAM,CACT,MAAMjB,EAAI,CAAE/E,KAAMd,EAAOO,KAAM,CAAC+D,GAAMtE,MAAOsG,GAE7C,YADAtF,EAAOE,KAAK2E,GAId,MAAOA,EAAGU,GAAKO,EAAKrC,SAAS6B,EAAGtG,GAEhC,GAAI6F,EAAJ,EACeA,EAAE7E,QAAU,CAAC6E,IACrBW,QAAQC,IACXA,EAAQlG,KAAO,CAAC+D,GAAKoC,OAAOD,EAAQlG,MACpCkG,EAAQ3F,KAAOd,EACfgB,EAAOE,KAAKuF,UAKZnC,KAAOtE,QAAeyF,IAANc,KAClBF,EAAI/B,GAAOiC,KAIRvF,EAAOR,OAAS,CAACwD,EAAS,GAAIhD,EAAO,GAAI,CAAEA,YAAa,MAACyE,EAAWY,KAc/E,SAASb,EAASb,EAAQC,EAAaC,GACrC,OAAOO,EAAM,CAACT,EAAQ,aAAcC,EAAaC,GAoFnD,SAASU,EAAOZ,EAAQC,EAAaC,GACnC,GAAuB,WAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,MAAM,MAAE5E,GAAU8E,EACZsC,EAAKpH,EAAM4E,GAEjB,GAAmB,aAAfjD,EAAOyF,GAIP,MAAM,IAAIhG,uBAAuBwD,KAIrC,MAAMmC,EAAO9B,EAAKmC,EAAIvC,GAEhBtE,EAAOqE,EAYb,OAAO,IAAIH,EAbE,SAaSlE,EAXLN,IACf,MAAOoG,EAAOL,GAAUe,EAAKrC,SAASzE,GAEtC,OAAIoG,GACFA,EAAM9F,KAAOA,EACN,CAAC8F,IAGH,MAACX,EAAWM,KAcvB,SAASjB,EAAMH,EAAQC,EAAaC,GAClC,GAAuB,UAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,MAAMyC,EAAQzC,EAAOgB,IAAIC,GAAKlB,EAAIkB,OAAGH,EAAWZ,IAC1CqB,EAAQX,EAAO,aAASE,EAAWZ,GAEnCvE,MAAW8G,EAAMzB,IAAI0B,GAAKA,EAAE/G,MAAMG,UAyCxC,OAAO,IAAI+D,EA1CE,QA0CSlE,EAxCL,CAACN,EAAQ8D,EAAgBc,MACxC,MAAOwB,GAASF,EAAMzB,SAASzE,GAE/B,GAAIoG,EAEF,OADAA,EAAM9F,KAAOA,EACN,CAAC8F,GAGV,MAAMC,EAAM,GACNrF,EAAS,GACTR,EAAS8G,KAAKC,IAAIvH,EAAMQ,OAAQ4G,EAAM5G,QAE5C,IAAK,IAAI2D,EAAI,EAAGA,EAAI3D,EAAQ2D,IAAK,CAC/B,MAAM2C,EAAOM,EAAMjD,GACbmC,EAAItG,EAAMmE,GAEhB,IAAK2C,EAAM,CACT,MAAMjB,EAAI,CAAE/E,KAAMd,EAAOO,KAAM,CAAC4D,GAAInE,MAAOsG,GAC3CtF,EAAOE,KAAK2E,GACZ,SAGF,MAAOA,EAAGU,GAAKO,EAAKrC,SAAS6B,GAE7B,GAAIT,EAAJ,EACeA,EAAE7E,QAAU,CAAC6E,IACrBW,QAAQC,IACXA,EAAQlG,KAAO,CAAC4D,GAAGuC,OAAOD,EAAQlG,MAClCkG,EAAQ3F,KAAOd,EACfgB,EAAOE,KAAKuF,UAKhBJ,EAAIlC,GAAKoC,EAGX,OAAOvF,EAAOR,OAAS,CAACwD,EAAS,GAAIhD,EAAO,GAAI,CAAEA,YAAa,MAACyE,EAAWY,KAc/E,SAASjB,EAAMT,EAAQC,EAAaC,GAClC,GAAuB,UAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,MAAMyC,EAAQzC,EAAOgB,IAAIC,GAAKlB,EAAIkB,OAAGH,EAAWZ,IAE1CvE,EAAO8G,EAAMzB,IAAI0B,GAAKA,EAAE/G,MAAMG,KAAK,OAiBzC,OAAO,IAAI+D,EAlBE,QAkBSlE,EAhBL,CAACN,EAAQ8D,EAAgBc,MACxC,MAAM5D,EAAS,GAEf,IAAK,MAAMqG,KAAKD,EAAO,CACrB,MAAOvB,EAAGU,GAAKc,EAAE5C,SAASzE,GAE1B,IAAK6F,EACH,MAAO,MAACJ,EAAWc,GAGrBvF,EAAOE,KAAK2E,GAGd,OADA7E,EAAO,GAAGV,KAAOA,EACVU,IAcX,SAASsE,EAAaX,EAAQC,EAAaC,GACzC,GAAuB,UAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,MAAM5E,EAAQ4E,EAAOgB,IAAIC,GAAKlB,EAAIkB,OAAGH,EAAWZ,IAE1CvE,EAAOP,EAAM4F,IAAI6B,GAAKA,EAAElH,MAAMG,KAAK,OAkBzC,OAAO,IAAI+D,EAnBE,eAmBSlE,EAjBL,CAACN,EAAQ8D,EAAgBc,MACxC,IAAI0B,EAAItG,EAER,IAAK,MAAMwH,KAAKzH,EAAO,CACrB,MAAO8F,EAAGU,GAAKiB,EAAE/C,SAAS6B,GAE1B,GAAIT,EAEF,OADAA,EAAEvF,KAAOA,EACF,CAACuF,GAGVS,EAAIC,EAGN,MAAO,MAACd,EAAWa,KAYvB,MAAMmB,EAAQ,CACZ/C,MACAgD,KAnwBF,SAAc/C,EAAQC,EAAaC,GACjC,GAAuB,UAAnBnD,EAAOiD,IAAyC,IAAlBA,EAAOnE,OAIrC,MAAM,IAAIW,yBAAyBwD,KAIvC,MAAMgC,EAAMpB,EAAO,cAAUE,EAAWZ,GAClCmC,EAAOtC,EAAIC,EAAO,QAAIc,EAAWZ,GACjC8C,EAASjD,EAAIC,EAAO,QAAIc,EAAWZ,GAEnCvE,UAAe0G,EAAK1G,QAAQqH,EAAOrH,QA+CzC,OAAO,IAAIkE,EAhDE,OAgDSlE,EA9CLN,IACf,MAAM4H,EAAW9D,EAAgBc,GACjC5E,EAAQ4H,EAAW5D,EAAS,GAAI4D,EAAU5H,GAASA,EACnD,MAAOoG,GAASO,EAAIlC,SAASzE,GAE7B,GAAIoG,EAEF,OADAA,EAAM9F,KAAOA,EACN,CAAC8F,GAGV,MAAMC,EAAM,GACNrF,EAAS,GAEf,IAAK,IAAIqG,KAAKrH,EAAO,CACnB,MAAMsG,EAAItG,EAAMqH,IACTxB,EAAGU,GAAKS,EAAKvC,SAAS4C,GAE7B,GAAIxB,EAAG,EACQA,EAAE7E,QAAU,CAAC6E,IACrBW,QAAQC,IACXA,EAAQlG,KAAO,CAAC8G,GAAGX,OAAOD,EAAQlG,MAClCkG,EAAQ3F,KAAOd,EACfgB,EAAOE,KAAKuF,KAEd,SAGFY,EAAId,EACJ,MAAOsB,EAAIC,GAAMH,EAAOlD,SAAS6B,GAEjC,GAAIuB,EAAJ,EACgBA,EAAG7G,QAAU,CAAC6G,IACtBrB,QAAQC,IACZA,EAAQlG,KAAO,CAAC8G,GAAGX,OAAOD,EAAQlG,MAClCkG,EAAQ3F,KAAOd,EACfgB,EAAOE,KAAKuF,UAKhBJ,EAAIgB,GAAKS,EAGX,OAAO9G,EAAOR,OAAS,CAACwD,EAAS,GAAIhD,EAAO,GAAI,CAAEA,YAAa,MAACyE,EAAWY,MA2sB7E0B,KAAMrC,EACNsC,MA7pBF,SAAerD,EAAQC,EAAaC,GAGlC,OADUE,EAAK,CADLW,EAAGf,OAAQc,IACDb,EAAaC,IA4pBjCoD,SAAUjD,EACVkD,SAvlBF,SAAkBvD,EAAQC,EAAaC,GACrC,MACMvE,cAAmBqE,EAAOjB,QAKhC,OAAO,IAAIc,EANE,WAMSlE,EAJL,CAACN,EAAQ8D,EAAgBc,KACjC5E,aAAiB2E,EAAS,MAACc,EAAWzF,GAAS,CAAC,CAAEc,KAAMd,EAAOO,KAAM,GAAIP,QAAOM,WAolBzF6H,UAtkBF,SAAexD,EAAQC,EAAaC,GAClC,GAAuB,WAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,MAAMgC,EAAMpB,EAAO,cAAUE,EAAWZ,GAClC+B,EAAK,GACLC,EAAa,GAEnB,IAAK,MAAMvC,KAAOK,EAAQ,CACxBiC,EAAG1F,KAAKoD,GACR,MACMwC,EAAOpC,EADHC,EAAOL,QACGmB,EAAWZ,GAC/BgC,EAAWvC,GAAOwC,EAGpB,MACMxG,MAAWsG,EAAGnG,UAyCpB,OAAO,IAAI+D,EA1CE,YA0CSlE,EAxCL,CAACN,EAAQ8D,EAAgBc,MACxC,MAAOwB,GAASO,EAAIlC,SAASzE,GAE7B,GAAIoG,EAEF,OADAA,EAAM9F,KAAOA,EACN,CAAC8F,GAGV,MAAMpF,EAAS,GACTqF,EAAMrG,EAEZ,IAAK,MAAMsE,KAAOuC,EAAY,CAC5B,IAAIP,EAAItG,EAAMsE,GACd,MAAMwC,EAAOD,EAAWvC,GAExB,QAAUmB,IAANa,EAAiB,CAEnBA,EAAIxC,EADMc,GAAeA,EAAYN,GACdtE,GAGzB,MAAO6F,EAAGU,GAAKO,EAAKrC,SAAS6B,EAAGtG,GAEhC,GAAI6F,EAAJ,EACeA,EAAE7E,QAAU,CAAC6E,IACrBW,QAAQC,IACXA,EAAQlG,KAAO,CAAC+D,GAAKoC,OAAOD,EAAQlG,MACpCkG,EAAQ3F,KAAOd,EACfgB,EAAOE,KAAKuF,UAKZnC,KAAOtE,QAAeyF,IAANc,KAClBF,EAAI/B,GAAOiC,GAIf,OAAOvF,EAAOR,OAAS,CAACwD,EAAS,GAAIhD,EAAO,GAAI,CAAEA,YAAa,MAACyE,EAAWY,MA4gB7E+B,KA9fF,SAAczD,EAAQC,EAAaC,GACjC,GAAuB,aAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,IAAImC,EACAhH,EAYJ,OADAgH,EAAO,IAAItC,EAVE,OACA,UACGxE,IACdF,EAAS6E,IACTmC,EAAKpD,KAAO5D,EAAOgH,KACnBA,EAAKxG,KAAOR,EAAOQ,KACnBwG,EAAKrC,SAAW3E,EAAO2E,SAChBqC,EAAKrC,SAASzE,MA6evB+E,OACAsD,QA7XF,SAAiB1D,EAAQC,EAAaC,GACpC,MACMvE,cAAmBI,KAAKC,UAAUgE,KAKxC,OAAO,IAAIH,EANE,UAMSlE,EAJL,CAACN,EAAQ8D,EAAgBc,KACjC5E,IAAU2E,EAAS,MAACc,EAAWzF,GAAS,CAAC,CAAEc,KAAMd,EAAOO,KAAM,GAAIP,QAAOM,WA0XlF2E,SACAO,WACA8C,QAhRF,SAAiB3D,EAAQC,EAAaC,GACpC,GAAuB,WAAnBnD,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,MAAMgC,EAAMpB,EAAO,cAAUE,EAAWZ,GAClC+B,EAAK,GACLC,EAAa,GAEnB,IAAK,MAAMvC,KAAOK,EAAQ,CACxBiC,EAAG1F,KAAKoD,GACR,MACMwC,EAAOpC,EADHC,EAAOL,QACGmB,EAAWZ,GAC/BgC,EAAWvC,GAAOwC,EAGpB,MACMxG,MAAWsG,EAAGnG,cAyCpB,OAAO,IAAI+D,EA1CE,UA0CSlE,EAxCL,CAACN,EAAQ8D,EAAgBc,MACxC,MAAOwB,GAASO,EAAIlC,SAASzE,GAE7B,GAAIoG,EAEF,OADAA,EAAM9F,KAAOA,EACN,CAAC8F,GAGV,MAAMpF,EAAS,GACTqF,EAAM,GAEZ,IAAK,MAAM/B,KAAOuC,EAAY,CAC5B,IAAIP,EAAItG,EAAMsE,GACd,MAAMwC,EAAOD,EAAWvC,GAExB,QAAUmB,IAANa,EAAiB,CAEnBA,EAAIxC,EADMc,GAAeA,EAAYN,GACdtE,GAGzB,MAAO6F,EAAGU,GAAKO,EAAKrC,SAAS6B,EAAGtG,GAEhC,GAAI6F,EAAJ,EACeA,EAAE7E,QAAU,CAAC6E,IACrBW,QAAQC,IACXA,EAAQlG,KAAO,CAAC+D,GAAKoC,OAAOD,EAAQlG,MACpCkG,EAAQ3F,KAAOd,EACfgB,EAAOE,KAAKuF,UAKZnC,KAAOtE,QAAeyF,IAANc,KAClBF,EAAI/B,GAAOiC,GAIf,OAAOvF,EAAOR,OAAS,CAACwD,EAAS,GAAIhD,EAAO,GAAI,CAAEA,YAAa,MAACyE,EAAWY,MAsN7Ed,SACAT,QACAM,QACAE,eACAiD,QAveF,SAAiBC,EAAc5D,EAAaC,GAC1C,GAA6B,aAAzBnD,EAAO8G,GAIP,MAAM,IAAIrH,yBAAyBqH,KA0BvC,OAAO,IAAIhE,EAtBE,UACA,aACI,CAACxE,EAAQ8D,EAAgBc,GAAc9D,KACtD,MAAM6D,EAAS6D,EAAaxI,EAAOc,GAEnC,GAAuB,aAAnBY,EAAOiD,GAIP,MAAM,IAAIxD,yBAAyBwD,KAIvC,MAAOyB,EAAOL,GAAUpB,EAAOF,SAASzE,GAExC,OAAIoG,EACK,CAACA,GAGH,MAACX,EAAWM,OAmejB0C,EAAQ,CACZ/D,IAAK1E,QAAmByF,IAAVzF,GAuBhB,SAAS0I,EAAYC,EAAS,IAC5B,MAAM5I,EAAQiE,EAAS,GAAIyE,EAAOE,EAAO5I,OAAS,IAWlD,SAASD,EAAO6E,EAAQC,EAAaC,EAAU,IACzChB,EAASc,KACXA,EAASA,EAAOA,QAGlB,MAAMmC,EAAOW,EAAM/C,IAAIC,EAAQC,EAAaZ,EAAS,GAAIa,EAAS,CAAE9E,WAEpE,SAAS6I,EAAO9H,GACd,GAAIG,gBAAgB2H,EAIhB,MAAM,IAAIzH,MAAM,0BAIpB,OAAOyH,EAAOC,OAAO/H,GAqCvB,OAlCAU,OAAOsH,eAAeF,EAAQjF,EAAW,CAAE3D,OAAO,IAClDwB,OAAOsH,eAAeF,EAAQhF,EAAM,CAAE5D,MAAO8G,IAE7C8B,EAAO9B,KAAOA,EAAKpD,KACnBkF,EAAOtI,KAAOwG,EAAKxG,KACnBsI,EAAOjE,OAASA,EAChBiE,EAAO7E,SAAWa,EAClBgE,EAAO/D,QAAUA,EAEjB+D,EAAOC,OAAS7I,IACd,MAAOoG,EAAOL,GAAUe,EAAKrC,SAASzE,GAEtC,GAAIoG,EACF,MAAM,IAAIjG,EAAYiG,GAGxB,OAAOL,GAGT6C,EAAOG,KAAO/I,IACZ,MAAOoG,GAASU,EAAKrC,SAASzE,GAC9B,OAAQoG,GAGVwC,EAAOnE,SAAWzE,IAChB,MAAOoG,EAAOL,GAAUe,EAAKrC,SAASzE,GAEtC,OAAIoG,EACK,CAAC,IAAIjG,EAAYiG,IAGnB,MAACX,EAAWM,IAGd6C,EAqBT,OAdApH,OAAOwF,KAAKS,GAAOjB,QAAQ9C,IACzB,MAAMoD,EAAOW,EAAM/D,GAEnB5D,EAAO4D,GAAQ,CAACiB,EAAQC,EAAaC,KAGnC,OADU/E,EADGgH,EAAKnC,EAAQC,EAAaZ,EAAS,GAAIa,EAAS,CAAE9E,WACxC6E,EAAaC,MASjC/E,EAtHK,CAAC,YAAa,QAAS,UAAW,SAAU,QAAS,eAAgB,eAAgB,WAAY,oBAAqB,aAAc,aAAc,YAAa,MAAO,OAAQ,SAAU,SAAU,UAAW,SAAU,MAAO,SAAU,SAAU,cAAe,cAAe,aAAc,oBAAqB,YAAa,UAAW,WAYnV0G,QAAQlG,IACZmI,EAAMnI,GAAQN,GAAS0B,EAAO1B,KAAWM,IAU3CmI,EAAMO,KAAOhJ,GAA2B,SAAlB0B,EAAO1B,KAAsBiJ,MAAMjJ,GAwG1C0I,K,uGCpsCf,IAAaQ,EAAb,cAAmCC,YAOjC,cACEvI,QACA,IAAWwI,SAASC,KAAQC,IAC1B,YAAUA,EAAGC,oBAAqB,cAEpCtI,KAAKuI,OAAS,GACKvI,KAAKwI,aAAa,CAAEC,KAAM,SAClCC,kDAEC,woCA6Bd,SAASC,GACP3I,KAAK4I,MAAQD,EACT3I,KAAK4I,OACP5I,KAAK6I,wBAIT,UAAU9J,GACJiB,KAAK8I,YACH/J,IAAUiB,KAAK8I,WAAWC,YAC5B/I,KAAK8I,WAAWE,SAASjK,GAG7BiB,KAAKuI,OAASxJ,EAGhB,YACE,OAAOiB,KAAK8I,WAAWC,WAGzB,kBACE,QAAO/I,KAAKiJ,WAAYC,cAAc,mBAGjC,oBACAlJ,KAAK8I,WAuBR9I,KAAK8I,WAAWK,WAtBhBnJ,KAAK8I,WAAa,IACf9I,KAAKiJ,WACN,CACElK,MAAOiB,KAAKuI,OACZa,aAAa,EACbX,KAAM,OACNY,QAAS,EACTC,WAAW,EACXC,eAAgBC,IAChBC,UAAW,CACTC,IAAK,aACL,YAAa,cAEfC,QACE3J,KAAK4I,OAAS,YAAW5I,KAAK4I,OAC1B,CAAC,aAAc,0BACf,KAGV5I,KAAK6I,wBACL7I,KAAK8I,WAAWc,GAAG,UAAW,IAAM5J,KAAK6J,cAMrC,YACN,YAAU7J,KAAM,eAAgB,CAAEjB,MAAOiB,KAAK8I,WAAWC,aAGnD,wBACD/I,KAAK8I,YAIV9I,KAAK8I,WACFR,oBACAwB,UAAUC,OAAO,MAAO,YAAW/J,KAAK4I,UA5GlCX,EAAa,aADzB,YAAc,oBACFA,I,iCCpBb,wHAsBA,MAAM+B,EAAiB,IAAO9C,UAAU,CACtC+C,MAAO,UACPC,MAAO,CAAC,UACRC,UAAW,IAAO5F,SAAS,CAAC,aAiM9B6F,eAAeC,OAAO,aA9LtB,cAAuC,IAQrC,wBACE,MAAO,CACL1B,KAAM,GACN2B,SAAU,GACVC,YAAa,GACbC,QAAS,GACTC,SAAU,IAIP,SACL,OAAO;;;;;;wBAMazK,KAAK0K;;;gBAGb1K,KAAK2I,KAAMgC,SACX;;;;gBAKA,YAAS,CACTC,OAAyB,IAAlB5K,KAAKwK,UAAwC,IAAlBxK,KAAKyK;;gBAGvCzK,KAAKyK,SACHzK,KAAK2I,KAAMgC,SACT,uDAEF3K,KAAK2I,KAAMgC,SACT;;yCAGqB3K,KAAK6K;iBAC7B7K,KAAK2I,KAAMgC,SACZ;;;;;;qBAOK3K,KAAK2I;6BACG3I,KAAK8K;0BACR9K,KAAK6K;;;;;MAQnB,eACR7K,KAAK+K,WAAWhM,MAAQ,IAAKiM,SAAShL,KAAKsK,SAAU5C,QACrD1H,KAAK+K,WAAWjC,WAAWmC,eAC3BjL,KAAKkL,YAAclL,KAAK+K,WAAWjC,WAAWqC,kBAAiB,GAGjE,oBACE,MAAO,CACL,IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAuCI,eACDnL,KAAKkL,cAGVlL,KAAKyK,UAAYzK,KAAK+K,WAAWjC,WAAWsC,QAAQpL,KAAKkL,aACrDlL,KAAKyK,WAAaY,OAAOC,eAC3BD,OAAOC,eAAiB,KACf,GAECtL,KAAKyK,UAAYY,OAAOC,iBAClCD,OAAOC,eAAiB,OAIpB,eACFtL,KAAKyK,WAEJc,QAAQ,8DAKbF,OAAOC,eAAiB,KACpBtL,KAAKuK,aACPvK,KAAKuK,eAID,oBAGN,GAFAvK,KAAKwK,SAAU,EAEXxK,KAAK+K,WAAWS,cAEfD,QACC,sFAGF,OAIJ,IAAIxM,EACJ,IACEA,EAAQ,IAAK0M,SAASzL,KAAK+K,WAAWhM,OACtC,MAAOiC,GAGP,OAFA0K,+BAA+B1K,UAC/BhB,KAAKwK,SAAU,GAGjB,IACEzL,EAAQiL,EAAejL,GACvB,MAAOiC,GAEP,YADA0K,mCAAmC1K,KAGrC,UACQhB,KAAKsK,SAAUqB,WAAW5M,GAChC,MAAOiC,GACP0K,8BAA8B1K,KAEhChB,KAAKkL,YAAclL,KAAK+K,WAAWjC,WAAWqC,kBAAiB,GAC/DE,OAAOC,eAAiB,KACxBtL,KAAKwK,SAAU,EACfxK,KAAKyK,UAAW,EAGlB,iBACE,OAAOzK,KAAKiJ,WAAYC,cAAc","file":"chunk.3971a124c883d9898c24.js","sourcesContent":["import { superstruct } from \"superstruct\";\nimport { isEntityId } from \"./is-entity-id\";\nimport { isIcon } from \"./is-icon\";\n\nexport const struct = superstruct({\n  types: {\n    \"entity-id\": isEntityId,\n    icon: isIcon,\n  },\n});\n","export function isEntityId(value: any): string | boolean {\n  if (typeof value !== \"string\") {\n    return \"entity id should be a string\";\n  }\n  if (!value.includes(\".\")) {\n    return \"entity id should be in the format 'domain.entity'\";\n  }\n  return true;\n}\n","export function isIcon(value: any): string | boolean {\n  if (typeof value !== \"string\") {\n    return \"icon should be a string\";\n  }\n  if (!value.includes(\":\")) {\n    return \"icon should be in the format 'mdi:icon'\";\n  }\n  return true;\n}\n","/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n  static format(attrs) {\n    const { type, path, value } = attrs;\n    const message = `Expected a value of type \\`${type}\\`${path.length ? ` for \\`${path.join('.')}\\`` : ''} but received \\`${JSON.stringify(value)}\\`.`;\n    return message;\n  }\n\n  constructor(attrs) {\n    const message = StructError.format(attrs);\n    super(message);\n\n    const { data, path, value, reason, type, errors = [] } = attrs;\n    this.data = data;\n    this.path = path;\n    this.value = value;\n    this.reason = reason;\n    this.type = type;\n    this.errors = errors;\n\n    if (!errors.length) {\n      errors.push(this);\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error().stack;\n    }\n  }\n}\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n\n/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@';\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@';\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nfunction isStruct(value) {\n  return !!(value && value[IS_STRUCT]);\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nfunction resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults;\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n  constructor(name, type, validate) {\n    this.name = name;\n    this.type = type;\n    this.validate = validate;\n  }\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults$$1, options) {\n  if (isStruct(schema)) {\n    return schema[KIND];\n  }\n\n  if (schema instanceof Kind) {\n    return schema;\n  }\n\n  switch (kindOf(schema)) {\n    case 'array':\n      {\n        return schema.length > 1 ? tuple(schema, defaults$$1, options) : list(schema, defaults$$1, options);\n      }\n\n    case 'function':\n      {\n        return func(schema, defaults$$1, options);\n      }\n\n    case 'object':\n      {\n        return object(schema, defaults$$1, options);\n      }\n\n    case 'string':\n      {\n        let required = true;\n        let type;\n\n        if (schema.endsWith('?')) {\n          required = false;\n          schema = schema.slice(0, -1);\n        }\n\n        if (schema.includes('|')) {\n          const scalars = schema.split(/\\s*\\|\\s*/g);\n          type = union(scalars, defaults$$1, options);\n        } else if (schema.includes('&')) {\n          const scalars = schema.split(/\\s*&\\s*/g);\n          type = intersection(scalars, defaults$$1, options);\n        } else {\n          type = scalar(schema, defaults$$1, options);\n        }\n\n        if (!required) {\n          type = optional(type, undefined, options);\n        }\n\n        return type;\n      }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(`A schema definition must be an object, array, string or function, but you passed: ${schema}`);\n  } else {\n    throw new Error(`Invalid schema: ${schema}`);\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Dict structs must be defined as an array with two elements, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const keys = any(schema[0], undefined, options);\n  const values = any(schema[1], undefined, options);\n  const name = 'dict';\n  const type = `dict<${keys.type},${values.type}>`;\n  const validate = value => {\n    const resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = {};\n    const errors = [];\n\n    for (let k in value) {\n      const v = value[k];\n      const [e, r] = keys.validate(k);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      k = r;\n      const [e2, r2] = values.validate(v);\n\n      if (e2) {\n        const allE2 = e2.errors || [e2];\n        allE2.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[k] = r2;\n    }\n\n    return errors.length ? [_extends({}, errors[0], { errors })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Enum structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'enum';\n  const type = schema.map(s => {\n    try {\n      return JSON.stringify(s);\n    } catch (e) {\n      return String(s);\n    }\n  }).join(' | ');\n\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return schema.includes(value) ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults$$1, options) {\n  const e = en(schema, undefined, options);\n  const l = list([e], defaults$$1, options);\n  return l;\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Function structs must be defined as a function, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'function';\n  const type = '<function>';\n  const validate = (value = resolveDefaults(defaults$$1), data) => {\n    const result = schema(value, data);\n    let failure = { path: [], reason: null };\n    let isValid;\n\n    switch (kindOf(result)) {\n      case 'boolean':\n        {\n          isValid = result;\n          break;\n        }\n      case 'string':\n        {\n          isValid = false;\n          failure.reason = result;\n          break;\n        }\n      case 'object':\n        {\n          isValid = false;\n          failure = _extends({}, failure, result);\n          break;\n        }\n      default:\n        {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`);\n          } else {\n            throw new Error(`Invalid result: ${result}`);\n          }\n        }\n    }\n\n    return isValid ? [undefined, value] : [_extends({ type, value, data: value }, failure)];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults$$1, options) {\n  const name = 'instance';\n  const type = `instance<${schema.name}>`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return value instanceof schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Interface structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'interface';\n  const type = `{${ks.join()}}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = value;\n\n    for (const key in properties) {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    }\n\n    return errors.length ? [_extends({}, errors[0], { errors })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  let kind;\n  let struct;\n  const name = 'lazy';\n  const type = `lazy...`;\n  const compile = value => {\n    struct = schema();\n    kind.name = struct.kind;\n    kind.type = struct.type;\n    kind.validate = struct.validate;\n    return kind.validate(value);\n  };\n\n  kind = new Kind(name, type, compile);\n  return kind;\n}\n\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction dynamic(createSchema, defaults$$1, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Dynamic structs must be defined as a function, but you passed: ${createSchema}`);\n    } else {\n      throw new Error(`Invalid schema: ${createSchema}`);\n    }\n  }\n\n  const name = 'dynamic';\n  const type = 'dynamic...';\n  const validate = (value = resolveDefaults(defaults$$1), data) => {\n    const schema = createSchema(value, data);\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`Dynamic structs must return a schema, but you passed: ${schema}`);\n      } else {\n        throw new Error(`Invalid schema: ${schema}`);\n      }\n    }\n\n    const [error, result] = schema.validate(value);\n\n    if (error) {\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`List structs must be defined as an array with a single element, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const array = scalar('array', undefined, options);\n  const element = any(schema[0], undefined, options);\n  const name = 'list';\n  const type = `[${element.type}]`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error, result] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    value = result;\n    const errors = [];\n    const ret = [];\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i];\n      const [e, r] = element.validate(v);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    return errors.length ? [_extends({}, errors[0], { errors })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults$$1, options) {\n  const name = 'literal';\n  const type = `literal: ${JSON.stringify(schema)}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return value === schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Object structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'object';\n  const type = `{${ks.join()}}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n    const valueKeys = Object.keys(value);\n    const propertiesKeys = Object.keys(properties);\n    const keys = new Set(valueKeys.concat(propertiesKeys));\n\n    keys.forEach(key => {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v };\n        errors.push(e);\n        return;\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    });\n\n    return errors.length ? [_extends({}, errors[0], { errors })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults$$1, options) {\n  return union([schema, 'undefined'], defaults$$1, options);\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Partial structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'partial';\n  const type = `{${ks.join()},...}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n\n    for (const key in properties) {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    }\n\n    return errors.length ? [_extends({}, errors[0], { errors })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Scalar structs must be defined as a string, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const { types } = options;\n  const fn = types[schema];\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`No struct validator function found for type \"${schema}\".`);\n    } else {\n      throw new Error(`Invalid type: ${schema}`);\n    }\n  }\n\n  const kind = func(fn, defaults$$1, options);\n  const name = 'scalar';\n  const type = schema;\n  const validate = value => {\n    const [error, result] = kind.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Tuple structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const array = scalar('array', undefined, options);\n  const name = 'tuple';\n  const type = `[${kinds.map(k => k.type).join()}]`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = [];\n    const errors = [];\n    const length = Math.max(value.length, kinds.length);\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i];\n      const v = value[i];\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v };\n        errors.push(e);\n        continue;\n      }\n\n      const [e, r] = kind.validate(v);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    return errors.length ? [_extends({}, errors[0], { errors })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Union structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const name = 'union';\n  const type = kinds.map(k => k.type).join(' | ');\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const errors = [];\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value);\n\n      if (!e) {\n        return [undefined, r];\n      }\n\n      errors.push(e);\n    }\n    errors[0].type = type;\n    return errors;\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Intersection structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options));\n  const name = 'intersection';\n  const type = types.map(t => t.type).join(' & ');\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    let v = value;\n\n    for (const t of types) {\n      const [e, r] = t.validate(v);\n\n      if (e) {\n        e.type = type;\n        return [e];\n      }\n\n      v = r;\n    }\n\n    return [undefined, v];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection,\n  dynamic\n\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = ['arguments', 'array', 'boolean', 'buffer', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined\n};\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type;\n});\n\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value);\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = _extends({}, Types, config.types || {});\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults$$1, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema;\n    }\n\n    const kind = Kinds.any(schema, defaults$$1, _extends({}, options, { types }));\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');\n        } else {\n          throw new Error('Invalid `new` keyword!');\n        }\n      }\n\n      return Struct.assert(data);\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true });\n    Object.defineProperty(Struct, KIND, { value: kind });\n\n    Struct.kind = kind.name;\n    Struct.type = kind.type;\n    Struct.schema = schema;\n    Struct.defaults = defaults$$1;\n    Struct.options = options;\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value);\n\n      if (error) {\n        throw new StructError(error);\n      }\n\n      return result;\n    };\n\n    Struct.test = value => {\n      const [error] = kind.validate(value);\n      return !error;\n    };\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value);\n\n      if (error) {\n        return [new StructError(error)];\n      }\n\n      return [undefined, result];\n    };\n\n    return Struct;\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name];\n\n    struct[name] = (schema, defaults$$1, options) => {\n      const type = kind(schema, defaults$$1, _extends({}, options, { types }));\n      const s = struct(type, defaults$$1, options);\n      return s;\n    };\n  });\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct;\n}\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct();\n\nexport { struct, superstruct, isStruct, StructError };\n//# sourceMappingURL=index.es.js.map\n","// @ts-ignore\nimport CodeMirror from \"codemirror\";\nimport \"codemirror/mode/yaml/yaml\";\n// @ts-ignore\nimport codeMirrorCSS from \"codemirror/lib/codemirror.css\";\nimport { HomeAssistant } from \"../../../types\";\nimport { fireEvent } from \"../../../common/dom/fire_event\";\nimport { computeRTL } from \"../../../common/util/compute_rtl\";\nimport { customElement } from \"lit-element\";\n\ndeclare global {\n  interface HASSDomEvents {\n    \"yaml-changed\": {\n      value: string;\n    };\n    \"yaml-save\": undefined;\n  }\n}\n\n@customElement(\"hui-yaml-editor\")\nexport class HuiYamlEditor extends HTMLElement {\n  public _hass?: HomeAssistant;\n\n  public codemirror!: any;\n\n  private _value: string;\n\n  public constructor() {\n    super();\n    CodeMirror.commands.save = (cm: CodeMirror) => {\n      fireEvent(cm.getWrapperElement(), \"yaml-save\");\n    };\n    this._value = \"\";\n    const shadowRoot = this.attachShadow({ mode: \"open\" });\n    shadowRoot.innerHTML = `\n            <style>\n              ${codeMirrorCSS}\n              .CodeMirror {\n                height: var(--code-mirror-height, auto);\n                direction: var(--code-mirror-direction, ltr);\n              }\n              .CodeMirror-scroll {\n                max-height: var(--code-mirror-max-height, --code-mirror-height);\n              }\n              .CodeMirror-gutters {\n                border-right: 1px solid var(--paper-input-container-color, var(--secondary-text-color));\n                background-color: var(--paper-dialog-background-color, var(--primary-background-color));\n                transition: 0.2s ease border-right;\n              }\n              .CodeMirror-focused .CodeMirror-gutters {\n                border-right: 2px solid var(--paper-input-container-focus-color, var(--primary-color));;\n              }\n              .CodeMirror-linenumber {\n                color: var(--paper-dialog-color, var(--primary-text-color));\n              }\n              .rtl .CodeMirror-vscrollbar {\n                right: auto;\n                left: 0px;\n              }\n              .rtl-gutter {\n                width: 20px;\n              }\n            </style>`;\n  }\n\n  set hass(hass: HomeAssistant) {\n    this._hass = hass;\n    if (this._hass) {\n      this.setScrollBarDirection();\n    }\n  }\n\n  set value(value: string) {\n    if (this.codemirror) {\n      if (value !== this.codemirror.getValue()) {\n        this.codemirror.setValue(value);\n      }\n    }\n    this._value = value;\n  }\n\n  get value(): string {\n    return this.codemirror.getValue();\n  }\n\n  get hasComments(): boolean {\n    return this.shadowRoot!.querySelector(\"span.cm-comment\") ? true : false;\n  }\n\n  public connectedCallback(): void {\n    if (!this.codemirror) {\n      this.codemirror = CodeMirror(\n        (this.shadowRoot as unknown) as HTMLElement,\n        {\n          value: this._value,\n          lineNumbers: true,\n          mode: \"yaml\",\n          tabSize: 2,\n          autofocus: true,\n          viewportMargin: Infinity,\n          extraKeys: {\n            Tab: \"indentMore\",\n            \"Shift-Tab\": \"indentLess\",\n          },\n          gutters:\n            this._hass && computeRTL(this._hass!)\n              ? [\"rtl-gutter\", \"CodeMirror-linenumbers\"]\n              : [],\n        }\n      );\n      this.setScrollBarDirection();\n      this.codemirror.on(\"changes\", () => this._onChange());\n    } else {\n      this.codemirror.refresh();\n    }\n  }\n\n  private _onChange(): void {\n    fireEvent(this, \"yaml-changed\", { value: this.codemirror.getValue() });\n  }\n\n  private setScrollBarDirection(): void {\n    if (!this.codemirror) {\n      return;\n    }\n\n    this.codemirror\n      .getWrapperElement()\n      .classList.toggle(\"rtl\", computeRTL(this._hass!));\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-yaml-editor\": HuiYamlEditor;\n  }\n}\n","import { LitElement, html, TemplateResult, CSSResult, css } from \"lit-element\";\nimport { classMap } from \"lit-html/directives/class-map\";\nimport yaml from \"js-yaml\";\n\nimport \"@polymer/app-layout/app-header-layout/app-header-layout\";\nimport \"@polymer/app-layout/app-header/app-header\";\nimport \"@polymer/app-layout/app-toolbar/app-toolbar\";\nimport \"@material/mwc-button\";\nimport \"@polymer/paper-icon-button/paper-icon-button\";\nimport \"@polymer/paper-spinner/paper-spinner\";\n\nimport { struct } from \"./common/structs/struct\";\nimport { Lovelace } from \"./types\";\n\nimport \"../../components/ha-icon\";\nimport { haStyle } from \"../../resources/styles\";\nimport \"./components/hui-yaml-editor\";\n// This is not a duplicate import, one is for types, one is for element.\n// tslint:disable-next-line\nimport { HuiYamlEditor } from \"./components/hui-yaml-editor\";\nimport { HomeAssistant } from \"../../types\";\n\nconst lovelaceStruct = struct.interface({\n  title: \"string?\",\n  views: [\"object\"],\n  resources: struct.optional([\"object\"]),\n});\n\nclass LovelaceFullConfigEditor extends LitElement {\n  public hass?: HomeAssistant;\n  public lovelace?: Lovelace;\n  public closeEditor?: () => void;\n  private _saving?: boolean;\n  private _changed?: boolean;\n  private _generation?: number;\n\n  static get properties() {\n    return {\n      hass: {},\n      lovelace: {},\n      closeEditor: {},\n      _saving: {},\n      _changed: {},\n    };\n  }\n\n  public render(): TemplateResult | void {\n    return html`\n      <app-header-layout>\n        <app-header>\n          <app-toolbar>\n            <paper-icon-button\n              icon=\"hass:close\"\n              @click=\"${this._closeEditor}\"\n            ></paper-icon-button>\n            <div main-title>\n              ${this.hass!.localize(\n                \"ui.panel.lovelace.editor.raw_editor.header\"\n              )}\n            </div>\n            <div\n              class=\"save-button\n              ${classMap({\n                saved: this._saving! === false || this._changed === true,\n              })}\"\n            >\n              ${this._changed\n                ? this.hass!.localize(\n                    \"ui.panel.lovelace.editor.raw_editor.unsaved_changes\"\n                  )\n                : this.hass!.localize(\n                    \"ui.panel.lovelace.editor.raw_editor.saved\"\n                  )}\n            </div>\n            <mwc-button raised @click=\"${this._handleSave}\"\n              >${this.hass!.localize(\n                \"ui.panel.lovelace.editor.raw_editor.save\"\n              )}</mwc-button\n            >\n          </app-toolbar>\n        </app-header>\n        <div class=\"content\">\n          <hui-yaml-editor\n            .hass=\"${this.hass}\"\n            @yaml-changed=\"${this._yamlChanged}\"\n            @yaml-save=\"${this._handleSave}\"\n          >\n          </hui-yaml-editor>\n        </div>\n      </app-header-layout>\n    `;\n  }\n\n  protected firstUpdated() {\n    this.yamlEditor.value = yaml.safeDump(this.lovelace!.config);\n    this.yamlEditor.codemirror.clearHistory();\n    this._generation = this.yamlEditor.codemirror.changeGeneration(true);\n  }\n\n  static get styles(): CSSResult[] {\n    return [\n      haStyle,\n      css`\n        :host {\n          --code-mirror-height: 100%;\n        }\n\n        app-header-layout {\n          height: 100vh;\n        }\n\n        app-toolbar {\n          background-color: var(--dark-background-color, #455a64);\n          color: var(--dark-text-color);\n        }\n\n        .comments {\n          font-size: 16px;\n        }\n\n        .content {\n          height: calc(100vh - 68px);\n        }\n\n        hui-code-editor {\n          height: 100%;\n        }\n\n        .save-button {\n          opacity: 0;\n          font-size: 14px;\n          padding: 0px 10px;\n        }\n\n        .saved {\n          opacity: 1;\n        }\n      `,\n    ];\n  }\n\n  private _yamlChanged() {\n    if (!this._generation) {\n      return;\n    }\n    this._changed = !this.yamlEditor.codemirror.isClean(this._generation);\n    if (this._changed && !window.onbeforeunload) {\n      window.onbeforeunload = () => {\n        return true;\n      };\n    } else if (!this._changed && window.onbeforeunload) {\n      window.onbeforeunload = null;\n    }\n  }\n\n  private _closeEditor() {\n    if (this._changed) {\n      if (\n        !confirm(\"You have unsaved changes, are you sure you want to exit?\")\n      ) {\n        return;\n      }\n    }\n    window.onbeforeunload = null;\n    if (this.closeEditor) {\n      this.closeEditor();\n    }\n  }\n\n  private async _handleSave() {\n    this._saving = true;\n\n    if (this.yamlEditor.hasComments) {\n      if (\n        !confirm(\n          \"Your config contains comment(s), these will not be saved. Do you want to continue?\"\n        )\n      ) {\n        return;\n      }\n    }\n\n    let value;\n    try {\n      value = yaml.safeLoad(this.yamlEditor.value);\n    } catch (err) {\n      alert(`Unable to parse YAML: ${err}`);\n      this._saving = false;\n      return;\n    }\n    try {\n      value = lovelaceStruct(value);\n    } catch (err) {\n      alert(`Your config is not valid: ${err}`);\n      return;\n    }\n    try {\n      await this.lovelace!.saveConfig(value);\n    } catch (err) {\n      alert(`Unable to save YAML: ${err}`);\n    }\n    this._generation = this.yamlEditor.codemirror.changeGeneration(true);\n    window.onbeforeunload = null;\n    this._saving = false;\n    this._changed = false;\n  }\n\n  private get yamlEditor(): HuiYamlEditor {\n    return this.shadowRoot!.querySelector(\"hui-yaml-editor\")!;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-editor\": LovelaceFullConfigEditor;\n  }\n}\n\ncustomElements.define(\"hui-editor\", LovelaceFullConfigEditor);\n"],"sourceRoot":""}